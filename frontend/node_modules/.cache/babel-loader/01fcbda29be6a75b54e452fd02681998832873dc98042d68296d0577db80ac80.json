{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/lucanest/Desktop/f.nosync/msaviz/frontend/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _reactDom = require(\"react-dom\");\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _reactDraggable = require(\"react-draggable\");\nvar _reactResizable = require(\"react-resizable\");\nvar _utils = require(\"./utils\");\nvar _calculateUtils = require(\"./calculateUtils\");\nvar _ReactGridLayoutPropTypes = require(\"./ReactGridLayoutPropTypes\");\nvar _clsx = _interopRequireDefault(require(\"clsx\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n/*:: import type { Element as ReactElement, Node as ReactNode } from \"react\";*/\n/*:: import type {\n  ReactDraggableCallbackData,\n  GridDragEvent,\n  GridResizeEvent,\n  DroppingPosition,\n  Position,\n  ResizeHandleAxis\n} from \"./utils\";*/\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: import type { ResizeHandle, ReactRef } from \"./ReactGridLayoutPropTypes\";*/\n/*:: type PartialPosition = { top: number, left: number };*/\n/*:: type GridItemCallback<Data: GridDragEvent | GridResizeEvent> = (\n  i: string,\n  w: number,\n  h: number,\n  Data\n) => void;*/\n/*:: type ResizeCallbackData = {\n  node: HTMLElement,\n  size: Position,\n  handle: ResizeHandleAxis\n};*/\n/*:: type GridItemResizeCallback = (\n  e: Event,\n  data: ResizeCallbackData,\n  position: Position\n) => void;*/\n/*:: type State = {\n  resizing: ?{ top: number, left: number, width: number, height: number },\n  dragging: ?{ top: number, left: number },\n  className: string\n};*/\n/*:: type Props = {\n  children: ReactElement<any>,\n  cols: number,\n  containerWidth: number,\n  margin: [number, number],\n  containerPadding: [number, number],\n  rowHeight: number,\n  maxRows: number,\n  isDraggable: boolean,\n  isResizable: boolean,\n  isBounded: boolean,\n  static?: boolean,\n  useCSSTransforms?: boolean,\n  usePercentages?: boolean,\n  transformScale: number,\n  droppingPosition?: DroppingPosition,\n\n  className: string,\n  style?: Object,\n  // Draggability\n  cancel: string,\n  handle: string,\n\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n\n  minW: number,\n  maxW: number,\n  minH: number,\n  maxH: number,\n  i: string,\n\n  resizeHandles?: ResizeHandleAxis[],\n  resizeHandle?: ResizeHandle,\n\n  onDrag?: GridItemCallback<GridDragEvent>,\n  onDragStart?: GridItemCallback<GridDragEvent>,\n  onDragStop?: GridItemCallback<GridDragEvent>,\n  onResize?: GridItemCallback<GridResizeEvent>,\n  onResizeStart?: GridItemCallback<GridResizeEvent>,\n  onResizeStop?: GridItemCallback<GridResizeEvent>\n};*/\n/*:: type DefaultProps = {\n  className: string,\n  cancel: string,\n  handle: string,\n  minH: number,\n  minW: number,\n  maxH: number,\n  maxW: number,\n  transformScale: number\n};*/\n/**\n * An individual item within a ReactGridLayout.\n */\nclass GridItem extends _react.default.Component /*:: <Props, State>*/ {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      resizing: null,\n      dragging: null,\n      className: \"\"\n    });\n    _defineProperty(this, \"elementRef\", /*#__PURE__*/_react.default.createRef());\n    /**\n     * onDragStart event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    _defineProperty(this, \"onDragStart\", (e, _ref) => {\n      let {\n        node\n      } = _ref;\n      const {\n        onDragStart,\n        transformScale\n      } = this.props;\n      if (!onDragStart) return;\n      const newPosition /*: PartialPosition*/ = {\n        top: 0,\n        left: 0\n      };\n\n      // TODO: this wont work on nested parents\n      const {\n        offsetParent\n      } = node;\n      if (!offsetParent) return;\n      const parentRect = offsetParent.getBoundingClientRect();\n      const clientRect = node.getBoundingClientRect();\n      const cLeft = clientRect.left / transformScale;\n      const pLeft = parentRect.left / transformScale;\n      const cTop = clientRect.top / transformScale;\n      const pTop = parentRect.top / transformScale;\n      newPosition.left = cLeft - pLeft + offsetParent.scrollLeft;\n      newPosition.top = cTop - pTop + offsetParent.scrollTop;\n      this.setState({\n        dragging: newPosition\n      });\n\n      // Call callback with this data\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(this.getPositionParams(), newPosition.top, newPosition.left, this.props.w, this.props.h);\n      return onDragStart.call(this, this.props.i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onDrag event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     * @param  {boolean} dontFlush    if true, will not call flushSync\n     */\n    _defineProperty(this, \"onDrag\", (e, _ref2, dontFlush) => {\n      let {\n        node,\n        deltaX,\n        deltaY\n      } = _ref2;\n      const {\n        onDrag\n      } = this.props;\n      if (!onDrag) return;\n      if (!this.state.dragging) {\n        throw new Error(\"onDrag called before onDragStart.\");\n      }\n      let top = this.state.dragging.top + deltaY;\n      let left = this.state.dragging.left + deltaX;\n      const {\n        isBounded,\n        i,\n        w,\n        h,\n        containerWidth\n      } = this.props;\n      const positionParams = this.getPositionParams();\n\n      // Boundary calculations; keeps items within the grid\n      if (isBounded) {\n        const {\n          offsetParent\n        } = node;\n        if (offsetParent) {\n          const {\n            margin,\n            rowHeight,\n            containerPadding\n          } = this.props;\n          const bottomBoundary = offsetParent.clientHeight - (0, _calculateUtils.calcGridItemWHPx)(h, rowHeight, margin[1]);\n          top = (0, _calculateUtils.clamp)(top - containerPadding[1], 0, bottomBoundary);\n          const colWidth = (0, _calculateUtils.calcGridColWidth)(positionParams);\n          const rightBoundary = containerWidth - (0, _calculateUtils.calcGridItemWHPx)(w, colWidth, margin[0]);\n          left = (0, _calculateUtils.clamp)(left - containerPadding[0], 0, rightBoundary);\n        }\n      }\n      const newPosition /*: PartialPosition*/ = {\n        top,\n        left\n      };\n\n      // dontFlush is set if we're calling from inside\n      if (dontFlush) {\n        this.setState({\n          dragging: newPosition\n        });\n      } else {\n        (0, _reactDom.flushSync)(() => {\n          this.setState({\n            dragging: newPosition\n          });\n        });\n      }\n\n      // Call callback with this data\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(positionParams, top, left, w, h);\n      return onDrag.call(this, i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onDragStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    _defineProperty(this, \"onDragStop\", (e, _ref3) => {\n      let {\n        node\n      } = _ref3;\n      const {\n        onDragStop\n      } = this.props;\n      if (!onDragStop) return;\n      if (!this.state.dragging) {\n        throw new Error(\"onDragEnd called before onDragStart.\");\n      }\n      const {\n        w,\n        h,\n        i\n      } = this.props;\n      const {\n        left,\n        top\n      } = this.state.dragging;\n      const newPosition /*: PartialPosition*/ = {\n        top,\n        left\n      };\n      this.setState({\n        dragging: null\n      });\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(this.getPositionParams(), top, left, w, h);\n      return onDragStop.call(this, i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onResizeStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node and size information\n     */\n    _defineProperty(this, \"onResizeStop\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResizeStop\"));\n    // onResizeStart event handler\n    _defineProperty(this, \"onResizeStart\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResizeStart\"));\n    // onResize event handler\n    _defineProperty(this, \"onResize\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResize\"));\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    // We can't deeply compare children. If the developer memoizes them, we can\n    // use this optimization.\n    if (this.props.children !== nextProps.children) return true;\n    if (this.props.droppingPosition !== nextProps.droppingPosition) return true;\n    // TODO memoize these calculations so they don't take so long?\n    const oldPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(this.props), this.props.x, this.props.y, this.props.w, this.props.h, this.state);\n    const newPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(nextProps), nextProps.x, nextProps.y, nextProps.w, nextProps.h, nextState);\n    return !(0, _utils.fastPositionEqual)(oldPosition, newPosition) || this.props.useCSSTransforms !== nextProps.useCSSTransforms;\n  }\n  componentDidMount() {\n    this.moveDroppingItem({});\n  }\n  componentDidUpdate(prevProps /*: Props*/) {\n    this.moveDroppingItem(prevProps);\n  }\n\n  // When a droppingPosition is present, this means we should fire a move event, as if we had moved\n  // this element by `x, y` pixels.\n  moveDroppingItem(prevProps /*: Props*/) {\n    const {\n      droppingPosition\n    } = this.props;\n    if (!droppingPosition) return;\n    const node = this.elementRef.current;\n    // Can't find DOM node (are we unmounted?)\n    if (!node) return;\n    const prevDroppingPosition = prevProps.droppingPosition || {\n      left: 0,\n      top: 0\n    };\n    const {\n      dragging\n    } = this.state;\n    const shouldDrag = dragging && droppingPosition.left !== prevDroppingPosition.left || droppingPosition.top !== prevDroppingPosition.top;\n    if (!dragging) {\n      this.onDragStart(droppingPosition.e, {\n        node,\n        deltaX: droppingPosition.left,\n        deltaY: droppingPosition.top\n      });\n    } else if (shouldDrag) {\n      const deltaX = droppingPosition.left - dragging.left;\n      const deltaY = droppingPosition.top - dragging.top;\n      this.onDrag(droppingPosition.e, {\n        node,\n        deltaX,\n        deltaY\n      }, true // dontFLush: avoid flushSync to temper warnings\n      );\n    }\n  }\n  getPositionParams() /*: PositionParams*/{\n    let props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n    return {\n      cols: props.cols,\n      containerPadding: props.containerPadding,\n      containerWidth: props.containerWidth,\n      margin: props.margin,\n      maxRows: props.maxRows,\n      rowHeight: props.rowHeight\n    };\n  }\n\n  /**\n   * This is where we set the grid item's absolute placement. It gets a little tricky because we want to do it\n   * well when server rendering, and the only way to do that properly is to use percentage width/left because\n   * we don't know exactly what the browser viewport is.\n   * Unfortunately, CSS Transforms, which are great for performance, break in this instance because a percentage\n   * left is relative to the item itself, not its container! So we cannot use them on the server rendering pass.\n   *\n   * @param  {Object} pos Position object with width, height, left, top.\n   * @return {Object}     Style object.\n   */\n  createStyle(pos /*: Position*/) /*: { [key: string]: ?string }*/{\n    const {\n      usePercentages,\n      containerWidth,\n      useCSSTransforms\n    } = this.props;\n    let style;\n    // CSS Transforms support (default)\n    if (useCSSTransforms) {\n      style = (0, _utils.setTransform)(pos);\n    } else {\n      // top,left (slow)\n      style = (0, _utils.setTopLeft)(pos);\n\n      // This is used for server rendering.\n      if (usePercentages) {\n        style.left = (0, _utils.perc)(pos.left / containerWidth);\n        style.width = (0, _utils.perc)(pos.width / containerWidth);\n      }\n    }\n    return style;\n  }\n\n  /**\n   * Mix a Draggable instance into a child.\n   * @param  {Element} child    Child element.\n   * @return {Element}          Child wrapped in Draggable.\n   */\n  mixinDraggable(child /*: ReactElement<any>*/, isDraggable /*: boolean*/) /*: ReactElement<any>*/{\n    return /*#__PURE__*/_react.default.createElement(_reactDraggable.DraggableCore, {\n      disabled: !isDraggable,\n      onStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onStop: this.onDragStop,\n      handle: this.props.handle,\n      cancel: \".react-resizable-handle\" + (this.props.cancel ? \",\" + this.props.cancel : \"\"),\n      scale: this.props.transformScale,\n      nodeRef: this.elementRef\n    }, child);\n  }\n\n  /**\n   * Utility function to setup callback handler definitions for\n   * similarily structured resize events.\n   */\n  curryResizeHandler(position /*: Position*/, handler /*: Function*/) /*: Function*/{\n    return (e /*: Event*/, data /*: ResizeCallbackData*/) => /*: Function*/handler(e, data, position);\n  }\n\n  /**\n   * Mix a Resizable instance into a child.\n   * @param  {Element} child    Child element.\n   * @param  {Object} position  Position object (pixel values)\n   * @return {Element}          Child wrapped in Resizable.\n   */\n  mixinResizable(child /*: ReactElement<any>*/, position /*: Position*/, isResizable /*: boolean*/) /*: ReactElement<any>*/{\n    const {\n      cols,\n      minW,\n      minH,\n      maxW,\n      maxH,\n      transformScale,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const positionParams = this.getPositionParams();\n\n    // This is the max possible width - doesn't go to infinity because of the width of the window\n    const maxWidth = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, cols, 0).width;\n\n    // Calculate min/max constraints using our min & maxes\n    const mins = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, minW, minH);\n    const maxes = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, maxW, maxH);\n    const minConstraints = [mins.width, mins.height];\n    const maxConstraints = [Math.min(maxes.width, maxWidth), Math.min(maxes.height, Infinity)];\n    return /*#__PURE__*/_react.default.createElement(_reactResizable.Resizable\n    // These are opts for the resize handle itself\n    , {\n      draggableOpts: {\n        disabled: !isResizable\n      },\n      className: isResizable ? undefined : \"react-resizable-hide\",\n      width: position.width,\n      height: position.height,\n      minConstraints: minConstraints,\n      maxConstraints: maxConstraints,\n      onResizeStop: this.curryResizeHandler(position, this.onResizeStop),\n      onResizeStart: this.curryResizeHandler(position, this.onResizeStart),\n      onResize: this.curryResizeHandler(position, this.onResize),\n      transformScale: transformScale,\n      resizeHandles: resizeHandles,\n      handle: resizeHandle\n    }, child);\n  }\n  /**\n   * Wrapper around resize events to provide more useful data.\n   */\n  onResizeHandler(e /*: Event*/, _ref4 /*:: */,\n  // 'size' is updated position\n  position /*: Position*/,\n  // existing position\n  handlerName /*: string*/) /*: void*/{\n    let {\n      node,\n      size,\n      handle\n    } /*: ResizeCallbackData*/ = _ref4 /*: ResizeCallbackData*/;\n    const handler = this.props[handlerName];\n    if (!handler) return;\n    const {\n      x,\n      y,\n      i,\n      maxH,\n      minH,\n      containerWidth\n    } = this.props;\n    const {\n      minW,\n      maxW\n    } = this.props;\n\n    // Clamping of dimensions based on resize direction\n    let updatedSize = size;\n    if (node) {\n      updatedSize = (0, _utils.resizeItemInDirection)(handle, position, size, containerWidth);\n      (0, _reactDom.flushSync)(() => {\n        this.setState({\n          resizing: handlerName === \"onResizeStop\" ? null : updatedSize\n        });\n      });\n    }\n\n    // Get new XY based on pixel size\n    let {\n      w,\n      h\n    } = (0, _calculateUtils.calcWH)(this.getPositionParams(), updatedSize.width, updatedSize.height, x, y, handle);\n\n    // Min/max capping.\n    // minW should be at least 1 (TODO propTypes validation?)\n    w = (0, _calculateUtils.clamp)(w, Math.max(minW, 1), maxW);\n    h = (0, _calculateUtils.clamp)(h, minH, maxH);\n    handler.call(this, i, w, h, {\n      e,\n      node,\n      size: updatedSize,\n      handle\n    });\n  }\n  render() /*: ReactNode*/{\n    const {\n      x,\n      y,\n      w,\n      h,\n      isDraggable,\n      isResizable,\n      droppingPosition,\n      useCSSTransforms\n    } = this.props;\n    const pos = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(), x, y, w, h, this.state);\n    const child = _react.default.Children.only(this.props.children);\n\n    // Create the child element. We clone the existing element but modify its className and style.\n    let newChild = /*#__PURE__*/_react.default.cloneElement(child, {\n      ref: this.elementRef,\n      className: (0, _clsx.default)(\"react-grid-item\", child.props.className, this.props.className, {\n        static: this.props.static,\n        resizing: Boolean(this.state.resizing),\n        \"react-draggable\": isDraggable,\n        \"react-draggable-dragging\": Boolean(this.state.dragging),\n        dropping: Boolean(droppingPosition),\n        cssTransforms: useCSSTransforms\n      }),\n      // We can set the width and height on the child, but unfortunately we can't set the position.\n      style: _objectSpread(_objectSpread(_objectSpread({}, this.props.style), child.props.style), this.createStyle(pos))\n    });\n\n    // Resizable support. This is usually on but the user can toggle it off.\n    newChild = this.mixinResizable(newChild, pos, isResizable);\n\n    // Draggable support. This is always on, except for with placeholders.\n    newChild = this.mixinDraggable(newChild, isDraggable);\n    return newChild;\n  }\n}\nexports.default = GridItem;\n_defineProperty(GridItem, \"propTypes\", {\n  // Children must be only a single element\n  children: _propTypes.default.element,\n  // General grid attributes\n  cols: _propTypes.default.number.isRequired,\n  containerWidth: _propTypes.default.number.isRequired,\n  rowHeight: _propTypes.default.number.isRequired,\n  margin: _propTypes.default.array.isRequired,\n  maxRows: _propTypes.default.number.isRequired,\n  containerPadding: _propTypes.default.array.isRequired,\n  // These are all in grid units\n  x: _propTypes.default.number.isRequired,\n  y: _propTypes.default.number.isRequired,\n  w: _propTypes.default.number.isRequired,\n  h: _propTypes.default.number.isRequired,\n  // All optional\n  minW: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"minWidth not Number\");\n    if (value > props.w || value > props.maxW) return new Error(\"minWidth larger than item width/maxWidth\");\n  },\n  maxW: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"maxWidth not Number\");\n    if (value < props.w || value < props.minW) return new Error(\"maxWidth smaller than item width/minWidth\");\n  },\n  minH: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"minHeight not Number\");\n    if (value > props.h || value > props.maxH) return new Error(\"minHeight larger than item height/maxHeight\");\n  },\n  maxH: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"maxHeight not Number\");\n    if (value < props.h || value < props.minH) return new Error(\"maxHeight smaller than item height/minHeight\");\n  },\n  // ID is nice to have for callbacks\n  i: _propTypes.default.string.isRequired,\n  // Resize handle options\n  resizeHandles: _ReactGridLayoutPropTypes.resizeHandleAxesType,\n  resizeHandle: _ReactGridLayoutPropTypes.resizeHandleType,\n  // Functions\n  onDragStop: _propTypes.default.func,\n  onDragStart: _propTypes.default.func,\n  onDrag: _propTypes.default.func,\n  onResizeStop: _propTypes.default.func,\n  onResizeStart: _propTypes.default.func,\n  onResize: _propTypes.default.func,\n  // Flags\n  isDraggable: _propTypes.default.bool.isRequired,\n  isResizable: _propTypes.default.bool.isRequired,\n  isBounded: _propTypes.default.bool.isRequired,\n  static: _propTypes.default.bool,\n  // Use CSS transforms instead of top/left\n  useCSSTransforms: _propTypes.default.bool.isRequired,\n  transformScale: _propTypes.default.number,\n  // Others\n  className: _propTypes.default.string,\n  // Selector for draggable handle\n  handle: _propTypes.default.string,\n  // Selector for draggable cancel (see react-draggable)\n  cancel: _propTypes.default.string,\n  // Current position of a dropping element\n  droppingPosition: _propTypes.default.shape({\n    e: _propTypes.default.object.isRequired,\n    left: _propTypes.default.number.isRequired,\n    top: _propTypes.default.number.isRequired\n  })\n});\n_defineProperty(GridItem, \"defaultProps\", {\n  className: \"\",\n  cancel: \"\",\n  handle: \"\",\n  minH: 1,\n  minW: 1,\n  maxH: Infinity,\n  maxW: Infinity,\n  transformScale: 1\n});","map":{"version":3,"names":["_objectSpread","require","default","Object","defineProperty","exports","value","_react","_interopRequireDefault","_reactDom","_propTypes","_reactDraggable","_reactResizable","_utils","_calculateUtils","_ReactGridLayoutPropTypes","_clsx","obj","__esModule","_defineProperty","key","_toPropertyKey","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","Number","GridItem","Component","constructor","arguments","resizing","dragging","className","createRef","e","_ref","node","onDragStart","transformScale","props","newPosition","top","left","offsetParent","parentRect","getBoundingClientRect","clientRect","cLeft","pLeft","cTop","pTop","scrollLeft","scrollTop","setState","x","y","calcXY","getPositionParams","w","h","i","_ref2","dontFlush","deltaX","deltaY","onDrag","state","Error","isBounded","containerWidth","positionParams","margin","rowHeight","containerPadding","bottomBoundary","clientHeight","calcGridItemWHPx","clamp","colWidth","calcGridColWidth","rightBoundary","flushSync","_ref3","onDragStop","callbackData","position","onResizeHandler","shouldComponentUpdate","nextProps","nextState","children","droppingPosition","oldPosition","calcGridItemPosition","fastPositionEqual","useCSSTransforms","componentDidMount","moveDroppingItem","componentDidUpdate","prevProps","elementRef","current","prevDroppingPosition","shouldDrag","length","cols","maxRows","createStyle","pos","usePercentages","style","setTransform","setTopLeft","perc","width","mixinDraggable","child","isDraggable","createElement","DraggableCore","disabled","onStart","onStop","handle","cancel","scale","nodeRef","curryResizeHandler","handler","data","mixinResizable","isResizable","minW","minH","maxW","maxH","resizeHandles","resizeHandle","maxWidth","mins","maxes","minConstraints","height","maxConstraints","Math","min","Infinity","Resizable","draggableOpts","onResizeStop","onResizeStart","onResize","_ref4","handlerName","size","updatedSize","resizeItemInDirection","calcWH","max","render","Children","only","newChild","cloneElement","ref","static","Boolean","dropping","cssTransforms","element","number","isRequired","array","propName","string","resizeHandleAxesType","resizeHandleType","func","bool","shape","object"],"sources":["/Users/lucanest/Desktop/f.nosync/msaviz/frontend/node_modules/react-grid-layout/build/GridItem.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _reactDom = require(\"react-dom\");\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _reactDraggable = require(\"react-draggable\");\nvar _reactResizable = require(\"react-resizable\");\nvar _utils = require(\"./utils\");\nvar _calculateUtils = require(\"./calculateUtils\");\nvar _ReactGridLayoutPropTypes = require(\"./ReactGridLayoutPropTypes\");\nvar _clsx = _interopRequireDefault(require(\"clsx\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*:: import type { Element as ReactElement, Node as ReactNode } from \"react\";*/\n/*:: import type {\n  ReactDraggableCallbackData,\n  GridDragEvent,\n  GridResizeEvent,\n  DroppingPosition,\n  Position,\n  ResizeHandleAxis\n} from \"./utils\";*/\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: import type { ResizeHandle, ReactRef } from \"./ReactGridLayoutPropTypes\";*/\n/*:: type PartialPosition = { top: number, left: number };*/\n/*:: type GridItemCallback<Data: GridDragEvent | GridResizeEvent> = (\n  i: string,\n  w: number,\n  h: number,\n  Data\n) => void;*/\n/*:: type ResizeCallbackData = {\n  node: HTMLElement,\n  size: Position,\n  handle: ResizeHandleAxis\n};*/\n/*:: type GridItemResizeCallback = (\n  e: Event,\n  data: ResizeCallbackData,\n  position: Position\n) => void;*/\n/*:: type State = {\n  resizing: ?{ top: number, left: number, width: number, height: number },\n  dragging: ?{ top: number, left: number },\n  className: string\n};*/\n/*:: type Props = {\n  children: ReactElement<any>,\n  cols: number,\n  containerWidth: number,\n  margin: [number, number],\n  containerPadding: [number, number],\n  rowHeight: number,\n  maxRows: number,\n  isDraggable: boolean,\n  isResizable: boolean,\n  isBounded: boolean,\n  static?: boolean,\n  useCSSTransforms?: boolean,\n  usePercentages?: boolean,\n  transformScale: number,\n  droppingPosition?: DroppingPosition,\n\n  className: string,\n  style?: Object,\n  // Draggability\n  cancel: string,\n  handle: string,\n\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n\n  minW: number,\n  maxW: number,\n  minH: number,\n  maxH: number,\n  i: string,\n\n  resizeHandles?: ResizeHandleAxis[],\n  resizeHandle?: ResizeHandle,\n\n  onDrag?: GridItemCallback<GridDragEvent>,\n  onDragStart?: GridItemCallback<GridDragEvent>,\n  onDragStop?: GridItemCallback<GridDragEvent>,\n  onResize?: GridItemCallback<GridResizeEvent>,\n  onResizeStart?: GridItemCallback<GridResizeEvent>,\n  onResizeStop?: GridItemCallback<GridResizeEvent>\n};*/\n/*:: type DefaultProps = {\n  className: string,\n  cancel: string,\n  handle: string,\n  minH: number,\n  minW: number,\n  maxH: number,\n  maxW: number,\n  transformScale: number\n};*/\n/**\n * An individual item within a ReactGridLayout.\n */\nclass GridItem extends _react.default.Component /*:: <Props, State>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      resizing: null,\n      dragging: null,\n      className: \"\"\n    });\n    _defineProperty(this, \"elementRef\", /*#__PURE__*/_react.default.createRef());\n    /**\n     * onDragStart event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    _defineProperty(this, \"onDragStart\", (e, _ref) => {\n      let {\n        node\n      } = _ref;\n      const {\n        onDragStart,\n        transformScale\n      } = this.props;\n      if (!onDragStart) return;\n      const newPosition /*: PartialPosition*/ = {\n        top: 0,\n        left: 0\n      };\n\n      // TODO: this wont work on nested parents\n      const {\n        offsetParent\n      } = node;\n      if (!offsetParent) return;\n      const parentRect = offsetParent.getBoundingClientRect();\n      const clientRect = node.getBoundingClientRect();\n      const cLeft = clientRect.left / transformScale;\n      const pLeft = parentRect.left / transformScale;\n      const cTop = clientRect.top / transformScale;\n      const pTop = parentRect.top / transformScale;\n      newPosition.left = cLeft - pLeft + offsetParent.scrollLeft;\n      newPosition.top = cTop - pTop + offsetParent.scrollTop;\n      this.setState({\n        dragging: newPosition\n      });\n\n      // Call callback with this data\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(this.getPositionParams(), newPosition.top, newPosition.left, this.props.w, this.props.h);\n      return onDragStart.call(this, this.props.i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onDrag event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     * @param  {boolean} dontFlush    if true, will not call flushSync\n     */\n    _defineProperty(this, \"onDrag\", (e, _ref2, dontFlush) => {\n      let {\n        node,\n        deltaX,\n        deltaY\n      } = _ref2;\n      const {\n        onDrag\n      } = this.props;\n      if (!onDrag) return;\n      if (!this.state.dragging) {\n        throw new Error(\"onDrag called before onDragStart.\");\n      }\n      let top = this.state.dragging.top + deltaY;\n      let left = this.state.dragging.left + deltaX;\n      const {\n        isBounded,\n        i,\n        w,\n        h,\n        containerWidth\n      } = this.props;\n      const positionParams = this.getPositionParams();\n\n      // Boundary calculations; keeps items within the grid\n      if (isBounded) {\n        const {\n          offsetParent\n        } = node;\n        if (offsetParent) {\n          const {\n            margin,\n            rowHeight,\n            containerPadding\n          } = this.props;\n          const bottomBoundary = offsetParent.clientHeight - (0, _calculateUtils.calcGridItemWHPx)(h, rowHeight, margin[1]);\n          top = (0, _calculateUtils.clamp)(top - containerPadding[1], 0, bottomBoundary);\n          const colWidth = (0, _calculateUtils.calcGridColWidth)(positionParams);\n          const rightBoundary = containerWidth - (0, _calculateUtils.calcGridItemWHPx)(w, colWidth, margin[0]);\n          left = (0, _calculateUtils.clamp)(left - containerPadding[0], 0, rightBoundary);\n        }\n      }\n      const newPosition /*: PartialPosition*/ = {\n        top,\n        left\n      };\n\n      // dontFlush is set if we're calling from inside\n      if (dontFlush) {\n        this.setState({\n          dragging: newPosition\n        });\n      } else {\n        (0, _reactDom.flushSync)(() => {\n          this.setState({\n            dragging: newPosition\n          });\n        });\n      }\n\n      // Call callback with this data\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(positionParams, top, left, w, h);\n      return onDrag.call(this, i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onDragStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    _defineProperty(this, \"onDragStop\", (e, _ref3) => {\n      let {\n        node\n      } = _ref3;\n      const {\n        onDragStop\n      } = this.props;\n      if (!onDragStop) return;\n      if (!this.state.dragging) {\n        throw new Error(\"onDragEnd called before onDragStart.\");\n      }\n      const {\n        w,\n        h,\n        i\n      } = this.props;\n      const {\n        left,\n        top\n      } = this.state.dragging;\n      const newPosition /*: PartialPosition*/ = {\n        top,\n        left\n      };\n      this.setState({\n        dragging: null\n      });\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(this.getPositionParams(), top, left, w, h);\n      return onDragStop.call(this, i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onResizeStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node and size information\n     */\n    _defineProperty(this, \"onResizeStop\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResizeStop\"));\n    // onResizeStart event handler\n    _defineProperty(this, \"onResizeStart\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResizeStart\"));\n    // onResize event handler\n    _defineProperty(this, \"onResize\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResize\"));\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    // We can't deeply compare children. If the developer memoizes them, we can\n    // use this optimization.\n    if (this.props.children !== nextProps.children) return true;\n    if (this.props.droppingPosition !== nextProps.droppingPosition) return true;\n    // TODO memoize these calculations so they don't take so long?\n    const oldPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(this.props), this.props.x, this.props.y, this.props.w, this.props.h, this.state);\n    const newPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(nextProps), nextProps.x, nextProps.y, nextProps.w, nextProps.h, nextState);\n    return !(0, _utils.fastPositionEqual)(oldPosition, newPosition) || this.props.useCSSTransforms !== nextProps.useCSSTransforms;\n  }\n  componentDidMount() {\n    this.moveDroppingItem({});\n  }\n  componentDidUpdate(prevProps /*: Props*/) {\n    this.moveDroppingItem(prevProps);\n  }\n\n  // When a droppingPosition is present, this means we should fire a move event, as if we had moved\n  // this element by `x, y` pixels.\n  moveDroppingItem(prevProps /*: Props*/) {\n    const {\n      droppingPosition\n    } = this.props;\n    if (!droppingPosition) return;\n    const node = this.elementRef.current;\n    // Can't find DOM node (are we unmounted?)\n    if (!node) return;\n    const prevDroppingPosition = prevProps.droppingPosition || {\n      left: 0,\n      top: 0\n    };\n    const {\n      dragging\n    } = this.state;\n    const shouldDrag = dragging && droppingPosition.left !== prevDroppingPosition.left || droppingPosition.top !== prevDroppingPosition.top;\n    if (!dragging) {\n      this.onDragStart(droppingPosition.e, {\n        node,\n        deltaX: droppingPosition.left,\n        deltaY: droppingPosition.top\n      });\n    } else if (shouldDrag) {\n      const deltaX = droppingPosition.left - dragging.left;\n      const deltaY = droppingPosition.top - dragging.top;\n      this.onDrag(droppingPosition.e, {\n        node,\n        deltaX,\n        deltaY\n      }, true // dontFLush: avoid flushSync to temper warnings\n      );\n    }\n  }\n\n  getPositionParams() /*: PositionParams*/{\n    let props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n    return {\n      cols: props.cols,\n      containerPadding: props.containerPadding,\n      containerWidth: props.containerWidth,\n      margin: props.margin,\n      maxRows: props.maxRows,\n      rowHeight: props.rowHeight\n    };\n  }\n\n  /**\n   * This is where we set the grid item's absolute placement. It gets a little tricky because we want to do it\n   * well when server rendering, and the only way to do that properly is to use percentage width/left because\n   * we don't know exactly what the browser viewport is.\n   * Unfortunately, CSS Transforms, which are great for performance, break in this instance because a percentage\n   * left is relative to the item itself, not its container! So we cannot use them on the server rendering pass.\n   *\n   * @param  {Object} pos Position object with width, height, left, top.\n   * @return {Object}     Style object.\n   */\n  createStyle(pos /*: Position*/) /*: { [key: string]: ?string }*/{\n    const {\n      usePercentages,\n      containerWidth,\n      useCSSTransforms\n    } = this.props;\n    let style;\n    // CSS Transforms support (default)\n    if (useCSSTransforms) {\n      style = (0, _utils.setTransform)(pos);\n    } else {\n      // top,left (slow)\n      style = (0, _utils.setTopLeft)(pos);\n\n      // This is used for server rendering.\n      if (usePercentages) {\n        style.left = (0, _utils.perc)(pos.left / containerWidth);\n        style.width = (0, _utils.perc)(pos.width / containerWidth);\n      }\n    }\n    return style;\n  }\n\n  /**\n   * Mix a Draggable instance into a child.\n   * @param  {Element} child    Child element.\n   * @return {Element}          Child wrapped in Draggable.\n   */\n  mixinDraggable(child /*: ReactElement<any>*/, isDraggable /*: boolean*/) /*: ReactElement<any>*/{\n    return /*#__PURE__*/_react.default.createElement(_reactDraggable.DraggableCore, {\n      disabled: !isDraggable,\n      onStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onStop: this.onDragStop,\n      handle: this.props.handle,\n      cancel: \".react-resizable-handle\" + (this.props.cancel ? \",\" + this.props.cancel : \"\"),\n      scale: this.props.transformScale,\n      nodeRef: this.elementRef\n    }, child);\n  }\n\n  /**\n   * Utility function to setup callback handler definitions for\n   * similarily structured resize events.\n   */\n  curryResizeHandler(position /*: Position*/, handler /*: Function*/) /*: Function*/{\n    return (e /*: Event*/, data /*: ResizeCallbackData*/) => /*: Function*/handler(e, data, position);\n  }\n\n  /**\n   * Mix a Resizable instance into a child.\n   * @param  {Element} child    Child element.\n   * @param  {Object} position  Position object (pixel values)\n   * @return {Element}          Child wrapped in Resizable.\n   */\n  mixinResizable(child /*: ReactElement<any>*/, position /*: Position*/, isResizable /*: boolean*/) /*: ReactElement<any>*/{\n    const {\n      cols,\n      minW,\n      minH,\n      maxW,\n      maxH,\n      transformScale,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const positionParams = this.getPositionParams();\n\n    // This is the max possible width - doesn't go to infinity because of the width of the window\n    const maxWidth = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, cols, 0).width;\n\n    // Calculate min/max constraints using our min & maxes\n    const mins = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, minW, minH);\n    const maxes = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, maxW, maxH);\n    const minConstraints = [mins.width, mins.height];\n    const maxConstraints = [Math.min(maxes.width, maxWidth), Math.min(maxes.height, Infinity)];\n    return /*#__PURE__*/_react.default.createElement(_reactResizable.Resizable\n    // These are opts for the resize handle itself\n    , {\n      draggableOpts: {\n        disabled: !isResizable\n      },\n      className: isResizable ? undefined : \"react-resizable-hide\",\n      width: position.width,\n      height: position.height,\n      minConstraints: minConstraints,\n      maxConstraints: maxConstraints,\n      onResizeStop: this.curryResizeHandler(position, this.onResizeStop),\n      onResizeStart: this.curryResizeHandler(position, this.onResizeStart),\n      onResize: this.curryResizeHandler(position, this.onResize),\n      transformScale: transformScale,\n      resizeHandles: resizeHandles,\n      handle: resizeHandle\n    }, child);\n  }\n  /**\n   * Wrapper around resize events to provide more useful data.\n   */\n  onResizeHandler(e /*: Event*/, _ref4 /*:: */,\n  // 'size' is updated position\n  position /*: Position*/,\n  // existing position\n  handlerName /*: string*/) /*: void*/{\n    let {\n      node,\n      size,\n      handle\n    } /*: ResizeCallbackData*/ = _ref4 /*: ResizeCallbackData*/;\n    const handler = this.props[handlerName];\n    if (!handler) return;\n    const {\n      x,\n      y,\n      i,\n      maxH,\n      minH,\n      containerWidth\n    } = this.props;\n    const {\n      minW,\n      maxW\n    } = this.props;\n\n    // Clamping of dimensions based on resize direction\n    let updatedSize = size;\n    if (node) {\n      updatedSize = (0, _utils.resizeItemInDirection)(handle, position, size, containerWidth);\n      (0, _reactDom.flushSync)(() => {\n        this.setState({\n          resizing: handlerName === \"onResizeStop\" ? null : updatedSize\n        });\n      });\n    }\n\n    // Get new XY based on pixel size\n    let {\n      w,\n      h\n    } = (0, _calculateUtils.calcWH)(this.getPositionParams(), updatedSize.width, updatedSize.height, x, y, handle);\n\n    // Min/max capping.\n    // minW should be at least 1 (TODO propTypes validation?)\n    w = (0, _calculateUtils.clamp)(w, Math.max(minW, 1), maxW);\n    h = (0, _calculateUtils.clamp)(h, minH, maxH);\n    handler.call(this, i, w, h, {\n      e,\n      node,\n      size: updatedSize,\n      handle\n    });\n  }\n  render() /*: ReactNode*/{\n    const {\n      x,\n      y,\n      w,\n      h,\n      isDraggable,\n      isResizable,\n      droppingPosition,\n      useCSSTransforms\n    } = this.props;\n    const pos = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(), x, y, w, h, this.state);\n    const child = _react.default.Children.only(this.props.children);\n\n    // Create the child element. We clone the existing element but modify its className and style.\n    let newChild = /*#__PURE__*/_react.default.cloneElement(child, {\n      ref: this.elementRef,\n      className: (0, _clsx.default)(\"react-grid-item\", child.props.className, this.props.className, {\n        static: this.props.static,\n        resizing: Boolean(this.state.resizing),\n        \"react-draggable\": isDraggable,\n        \"react-draggable-dragging\": Boolean(this.state.dragging),\n        dropping: Boolean(droppingPosition),\n        cssTransforms: useCSSTransforms\n      }),\n      // We can set the width and height on the child, but unfortunately we can't set the position.\n      style: {\n        ...this.props.style,\n        ...child.props.style,\n        ...this.createStyle(pos)\n      }\n    });\n\n    // Resizable support. This is usually on but the user can toggle it off.\n    newChild = this.mixinResizable(newChild, pos, isResizable);\n\n    // Draggable support. This is always on, except for with placeholders.\n    newChild = this.mixinDraggable(newChild, isDraggable);\n    return newChild;\n  }\n}\nexports.default = GridItem;\n_defineProperty(GridItem, \"propTypes\", {\n  // Children must be only a single element\n  children: _propTypes.default.element,\n  // General grid attributes\n  cols: _propTypes.default.number.isRequired,\n  containerWidth: _propTypes.default.number.isRequired,\n  rowHeight: _propTypes.default.number.isRequired,\n  margin: _propTypes.default.array.isRequired,\n  maxRows: _propTypes.default.number.isRequired,\n  containerPadding: _propTypes.default.array.isRequired,\n  // These are all in grid units\n  x: _propTypes.default.number.isRequired,\n  y: _propTypes.default.number.isRequired,\n  w: _propTypes.default.number.isRequired,\n  h: _propTypes.default.number.isRequired,\n  // All optional\n  minW: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"minWidth not Number\");\n    if (value > props.w || value > props.maxW) return new Error(\"minWidth larger than item width/maxWidth\");\n  },\n  maxW: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"maxWidth not Number\");\n    if (value < props.w || value < props.minW) return new Error(\"maxWidth smaller than item width/minWidth\");\n  },\n  minH: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"minHeight not Number\");\n    if (value > props.h || value > props.maxH) return new Error(\"minHeight larger than item height/maxHeight\");\n  },\n  maxH: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"maxHeight not Number\");\n    if (value < props.h || value < props.minH) return new Error(\"maxHeight smaller than item height/minHeight\");\n  },\n  // ID is nice to have for callbacks\n  i: _propTypes.default.string.isRequired,\n  // Resize handle options\n  resizeHandles: _ReactGridLayoutPropTypes.resizeHandleAxesType,\n  resizeHandle: _ReactGridLayoutPropTypes.resizeHandleType,\n  // Functions\n  onDragStop: _propTypes.default.func,\n  onDragStart: _propTypes.default.func,\n  onDrag: _propTypes.default.func,\n  onResizeStop: _propTypes.default.func,\n  onResizeStart: _propTypes.default.func,\n  onResize: _propTypes.default.func,\n  // Flags\n  isDraggable: _propTypes.default.bool.isRequired,\n  isResizable: _propTypes.default.bool.isRequired,\n  isBounded: _propTypes.default.bool.isRequired,\n  static: _propTypes.default.bool,\n  // Use CSS transforms instead of top/left\n  useCSSTransforms: _propTypes.default.bool.isRequired,\n  transformScale: _propTypes.default.number,\n  // Others\n  className: _propTypes.default.string,\n  // Selector for draggable handle\n  handle: _propTypes.default.string,\n  // Selector for draggable cancel (see react-draggable)\n  cancel: _propTypes.default.string,\n  // Current position of a dropping element\n  droppingPosition: _propTypes.default.shape({\n    e: _propTypes.default.object.isRequired,\n    left: _propTypes.default.number.isRequired,\n    top: _propTypes.default.number.isRequired\n  })\n});\n_defineProperty(GridItem, \"defaultProps\", {\n  className: \"\",\n  cancel: \"\",\n  handle: \"\",\n  minH: 1,\n  minW: 1,\n  maxH: Infinity,\n  maxW: Infinity,\n  transformScale: 1\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}