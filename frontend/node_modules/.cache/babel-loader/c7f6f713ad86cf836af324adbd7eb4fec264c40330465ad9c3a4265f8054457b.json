{"ast":null,"code":"import { cast } from './cast';\n/**\n * Performs depth-first traversal of a Newick tree.\n * Returns a flat object mapping node names to branch lengths.\n *\n * @param tree - Newick tree or string\n * @param nodeCallback - Optional callback applied to each node\n * @returns Object mapping node names to branch lengths\n */\nexport function dfs(tree) {\n  let nodeCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e => e;\n  const vertex = {};\n  function _local_dfs(node) {\n    const branchset = node.branchset || [];\n    for (let i = 0; i < branchset.length; i++) {\n      const child = branchset[i];\n      if (child.name && typeof child.length === 'number') {\n        vertex[child.name] = child.length;\n      }\n      // Apply the callback and recurse\n      if (node.branchset && node.branchset[i]) {\n        node.branchset[i] = nodeCallback(child);\n      }\n      _local_dfs(child);\n    }\n  }\n  const parsedTree = cast(tree);\n  _local_dfs(parsedTree);\n  return vertex;\n}","map":{"version":3,"names":["cast","dfs","tree","nodeCallback","arguments","length","undefined","e","vertex","_local_dfs","node","branchset","i","child","name","parsedTree"],"sources":["/Users/lucanest/Desktop/f.nosync/msaviz/frontend/node_modules/newick/dist/esm/tools/dfs.js"],"sourcesContent":["import { cast } from './cast';\n/**\n * Performs depth-first traversal of a Newick tree.\n * Returns a flat object mapping node names to branch lengths.\n *\n * @param tree - Newick tree or string\n * @param nodeCallback - Optional callback applied to each node\n * @returns Object mapping node names to branch lengths\n */\nexport function dfs(tree, nodeCallback = (e) => e) {\n    const vertex = {};\n    function _local_dfs(node) {\n        const branchset = node.branchset || [];\n        for (let i = 0; i < branchset.length; i++) {\n            const child = branchset[i];\n            if (child.name && typeof child.length === 'number') {\n                vertex[child.name] = child.length;\n            }\n            // Apply the callback and recurse\n            if (node.branchset && node.branchset[i]) {\n                node.branchset[i] = nodeCallback(child);\n            }\n            _local_dfs(child);\n        }\n    }\n    const parsedTree = cast(tree);\n    _local_dfs(parsedTree);\n    return vertex;\n}\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,GAAGA,CAACC,IAAI,EAA2B;EAAA,IAAzBC,YAAY,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAIG,CAAC,IAAKA,CAAC;EAC7C,MAAMC,MAAM,GAAG,CAAC,CAAC;EACjB,SAASC,UAAUA,CAACC,IAAI,EAAE;IACtB,MAAMC,SAAS,GAAGD,IAAI,CAACC,SAAS,IAAI,EAAE;IACtC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,SAAS,CAACN,MAAM,EAAEO,CAAC,EAAE,EAAE;MACvC,MAAMC,KAAK,GAAGF,SAAS,CAACC,CAAC,CAAC;MAC1B,IAAIC,KAAK,CAACC,IAAI,IAAI,OAAOD,KAAK,CAACR,MAAM,KAAK,QAAQ,EAAE;QAChDG,MAAM,CAACK,KAAK,CAACC,IAAI,CAAC,GAAGD,KAAK,CAACR,MAAM;MACrC;MACA;MACA,IAAIK,IAAI,CAACC,SAAS,IAAID,IAAI,CAACC,SAAS,CAACC,CAAC,CAAC,EAAE;QACrCF,IAAI,CAACC,SAAS,CAACC,CAAC,CAAC,GAAGT,YAAY,CAACU,KAAK,CAAC;MAC3C;MACAJ,UAAU,CAACI,KAAK,CAAC;IACrB;EACJ;EACA,MAAME,UAAU,GAAGf,IAAI,CAACE,IAAI,CAAC;EAC7BO,UAAU,CAACM,UAAU,CAAC;EACtB,OAAOP,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}