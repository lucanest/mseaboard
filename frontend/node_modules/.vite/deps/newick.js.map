{
  "version": 3,
  "sources": ["../../newick/dist/esm/tools/parse.js", "../../newick/dist/esm/tools/cast.js", "../../newick/dist/esm/tools/dfs.js", "../../newick/dist/esm/tools/getRoot.js", "../../newick/dist/esm/tools/normalize.js", "../../newick/dist/esm/tools/serialize.js", "../../newick/dist/esm/tools/stringify.js", "../../newick/dist/esm/tools/map.js", "../../newick/dist/esm/entities/Newick.js"],
  "sourcesContent": ["export function parse(s) {\n    const ancestors = [];\n    let tree = {};\n    const tokens = s.split(/\\s*([;(),:])\\s*/);\n    let subtree;\n    for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i];\n        switch (token) {\n            case '(': {\n                // new branchset\n                subtree = {};\n                tree.branchset = [subtree];\n                ancestors.push(tree);\n                tree = subtree;\n                break;\n            }\n            case ',': {\n                // another branch\n                subtree = {};\n                const parent = ancestors[ancestors.length - 1];\n                if (!parent.branchset) {\n                    parent.branchset = [];\n                }\n                parent.branchset.push(subtree);\n                tree = subtree;\n                break;\n            }\n            case ')': {\n                // close branch\n                tree = ancestors.pop();\n                break;\n            }\n            case ':':\n                // length follows â€” handled in default\n                break;\n            default: {\n                const prev = tokens[i - 1];\n                if (prev === ')' || prev === '(' || prev === ',') {\n                    tree.name = token;\n                }\n                else if (prev === ':') {\n                    tree.length = parseFloat(token);\n                }\n                break;\n            }\n        }\n    }\n    return tree;\n}\n", "import { parse } from './parse';\n/**\n * Casts a Newick string or an object (stringified or not) to a tree object.\n * Accepts: Newick string, stringified JSON, or a NewickNode object.\n */\nexport function cast(input) {\n    if (typeof input === 'string') {\n        try {\n            return JSON.parse(input);\n        }\n        catch {\n            return parse(input);\n        }\n    }\n    return input;\n}\n", "import { cast } from './cast';\n/**\n * Performs depth-first traversal of a Newick tree.\n * Returns a flat object mapping node names to branch lengths.\n *\n * @param tree - Newick tree or string\n * @param nodeCallback - Optional callback applied to each node\n * @returns Object mapping node names to branch lengths\n */\nexport function dfs(tree, nodeCallback = (e) => e) {\n    const vertex = {};\n    function _local_dfs(node) {\n        const branchset = node.branchset || [];\n        for (let i = 0; i < branchset.length; i++) {\n            const child = branchset[i];\n            if (child.name && typeof child.length === 'number') {\n                vertex[child.name] = child.length;\n            }\n            // Apply the callback and recurse\n            if (node.branchset && node.branchset[i]) {\n                node.branchset[i] = nodeCallback(child);\n            }\n            _local_dfs(child);\n        }\n    }\n    const parsedTree = cast(tree);\n    _local_dfs(parsedTree);\n    return vertex;\n}\n", "import { cast } from './cast';\n/**\n * Returns the name of the root node of a Newick tree\n * @param tree - Newick string or tree object\n * @returns Root node name or null\n */\nexport function getRoot(tree) {\n    const obj = cast(tree);\n    if (typeof obj.name === 'string') {\n        if (obj.name === '') {\n            return null;\n        }\n        return obj.name;\n    }\n    return null;\n}\n", "import { cast } from './cast';\nimport { dfs } from './dfs';\n/**\n * Normalize branch lengths of a Newick tree so total length sums to 1\n * @param s - Newick string or tree object\n * @returns Normalized tree object\n */\nexport function normalize(s) {\n    const tree = cast(s);\n    function _local_normalize(tree) {\n        const vertex = dfs(tree);\n        const total = Object.values(vertex).reduce((acc, len) => acc + len, 0);\n        // Defensive: avoid division by zero\n        if (total === 0)\n            return tree;\n        // Here dfs takes two params: tree and optional nodeCallback\n        dfs(tree, (e) => {\n            if (typeof e.length === 'number') {\n                e.length = e.length / total;\n            }\n            return e;\n        });\n        return tree;\n    }\n    return _local_normalize(tree);\n}\n", "/**\n * Recursively serialize a NewickNode tree into a Newick-format string (without trailing semicolon)\n * @param node - Newick tree node\n * @returns Newick string for the node subtree\n */\nexport function serialize(node) {\n    let newick = '';\n    if (node.branchset && node.branchset.length > 0) {\n        newick += `(${node.branchset.map(serialize).join(',')})`;\n    }\n    if (node.name) {\n        newick += node.name;\n    }\n    if (typeof node.length === 'number') {\n        newick += `:${node.length}`;\n    }\n    return newick;\n}\n", "import { serialize } from './serialize';\n/**\n * Converts a NewickNode tree to a full Newick string with trailing semicolon\n * @param node - Newick tree node\n * @returns Newick format string\n */\nexport function stringify(node) {\n    return `${serialize(node)};`;\n}\n", "import { cast } from './cast';\nimport { dfs } from './dfs';\n/**\n * Applies a callback to each node of a Newick tree, returning the modified tree.\n * @param tree - Newick string or tree object\n * @param callback - Function applied to each node\n * @returns Modified tree object\n */\nexport function map(tree, callback = (e) => e) {\n    const castedTree = cast(tree);\n    // The original code had dfs(tree, null, callback)\n    // Our dfs only accepts (tree, nodeCallback)\n    dfs(castedTree, callback);\n    return castedTree;\n}\n", "import { cast } from '../tools/cast';\nimport { getRoot } from '../tools/getRoot';\nimport { dfs } from '../tools/dfs';\nimport { map } from '../tools/map';\nimport { normalize } from '../tools/normalize';\nimport { serialize } from '../tools/serialize';\nimport { parse } from '../tools/parse';\nexport class Newick {\n    constructor(data) {\n        this.tree = cast(data);\n    }\n    getRoot() {\n        return getRoot(this.tree);\n    }\n    dfs(callback) {\n        return dfs(this.tree, callback);\n    }\n    map(callback) {\n        this.tree = map(this.tree, callback);\n    }\n    normalize() {\n        return normalize(this.tree);\n    }\n    serialize() {\n        return serialize(this.tree);\n    }\n    toString() {\n        return serialize(this.tree);\n    }\n    clone() {\n        // Deep clone by serializing and reparsing\n        return new Newick(this.serialize());\n    }\n    equal(anotherTree) {\n        return (this.serialize().toLowerCase() === anotherTree.serialize().toLowerCase());\n    }\n    parse(string) {\n        return parse(string);\n    }\n}\n"],
  "mappings": "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",
  "names": ["tree"]
}
