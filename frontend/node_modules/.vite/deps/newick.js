import "./chunk-ROME4SDB.js";

// node_modules/newick/dist/esm/tools/parse.js
function parse(s) {
  const ancestors = [];
  let tree = {};
  const tokens = s.split(/\s*([;(),:])\s*/);
  let subtree;
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    switch (token) {
      case "(": {
        subtree = {};
        tree.branchset = [subtree];
        ancestors.push(tree);
        tree = subtree;
        break;
      }
      case ",": {
        subtree = {};
        const parent = ancestors[ancestors.length - 1];
        if (!parent.branchset) {
          parent.branchset = [];
        }
        parent.branchset.push(subtree);
        tree = subtree;
        break;
      }
      case ")": {
        tree = ancestors.pop();
        break;
      }
      case ":":
        break;
      default: {
        const prev = tokens[i - 1];
        if (prev === ")" || prev === "(" || prev === ",") {
          tree.name = token;
        } else if (prev === ":") {
          tree.length = parseFloat(token);
        }
        break;
      }
    }
  }
  return tree;
}

// node_modules/newick/dist/esm/tools/cast.js
function cast(input) {
  if (typeof input === "string") {
    try {
      return JSON.parse(input);
    } catch {
      return parse(input);
    }
  }
  return input;
}

// node_modules/newick/dist/esm/tools/dfs.js
function dfs(tree, nodeCallback = (e) => e) {
  const vertex = {};
  function _local_dfs(node) {
    const branchset = node.branchset || [];
    for (let i = 0; i < branchset.length; i++) {
      const child = branchset[i];
      if (child.name && typeof child.length === "number") {
        vertex[child.name] = child.length;
      }
      if (node.branchset && node.branchset[i]) {
        node.branchset[i] = nodeCallback(child);
      }
      _local_dfs(child);
    }
  }
  const parsedTree = cast(tree);
  _local_dfs(parsedTree);
  return vertex;
}

// node_modules/newick/dist/esm/tools/getRoot.js
function getRoot(tree) {
  const obj = cast(tree);
  if (typeof obj.name === "string") {
    if (obj.name === "") {
      return null;
    }
    return obj.name;
  }
  return null;
}

// node_modules/newick/dist/esm/tools/normalize.js
function normalize(s) {
  const tree = cast(s);
  function _local_normalize(tree2) {
    const vertex = dfs(tree2);
    const total = Object.values(vertex).reduce((acc, len) => acc + len, 0);
    if (total === 0)
      return tree2;
    dfs(tree2, (e) => {
      if (typeof e.length === "number") {
        e.length = e.length / total;
      }
      return e;
    });
    return tree2;
  }
  return _local_normalize(tree);
}

// node_modules/newick/dist/esm/tools/serialize.js
function serialize(node) {
  let newick = "";
  if (node.branchset && node.branchset.length > 0) {
    newick += `(${node.branchset.map(serialize).join(",")})`;
  }
  if (node.name) {
    newick += node.name;
  }
  if (typeof node.length === "number") {
    newick += `:${node.length}`;
  }
  return newick;
}

// node_modules/newick/dist/esm/tools/stringify.js
function stringify(node) {
  return `${serialize(node)};`;
}

// node_modules/newick/dist/esm/tools/map.js
function map(tree, callback = (e) => e) {
  const castedTree = cast(tree);
  dfs(castedTree, callback);
  return castedTree;
}

// node_modules/newick/dist/esm/entities/Newick.js
var Newick = class _Newick {
  constructor(data) {
    this.tree = cast(data);
  }
  getRoot() {
    return getRoot(this.tree);
  }
  dfs(callback) {
    return dfs(this.tree, callback);
  }
  map(callback) {
    this.tree = map(this.tree, callback);
  }
  normalize() {
    return normalize(this.tree);
  }
  serialize() {
    return serialize(this.tree);
  }
  toString() {
    return serialize(this.tree);
  }
  clone() {
    return new _Newick(this.serialize());
  }
  equal(anotherTree) {
    return this.serialize().toLowerCase() === anotherTree.serialize().toLowerCase();
  }
  parse(string) {
    return parse(string);
  }
};
export {
  Newick,
  cast,
  dfs,
  getRoot,
  map,
  normalize,
  parse,
  serialize,
  stringify
};
//# sourceMappingURL=newick.js.map
